{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Task Management System","text":"<p>A full-stack web application for managing tasks, built with Django REST Framework (backend) and React.js + Vite.js (frontend). This documentation provides everything you need to set up, run, and contribute to the Task Management System.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Task Creation and Management: Create, edit, delete tasks, assign due dates.</li> <li>Collaboration: Invite team members, comment on tasks, and track overall progress.</li> <li>Notifications: Receive reminders on due tasks.</li> <li>Analytics (Coming Soon): Dashboard and reports on project/task activity.</li> </ul>"},{"location":"#tech-stack","title":"Tech Stack","text":"<ul> <li>Backend: Django, Django REST Framework, Python</li> <li>Frontend: React.js, Vite.js, JavaScript</li> <li>Database: PostgreSQL</li> <li>Hosting: Render (backend), Netlify (frontend), Cloudinary (media assets)</li> <li>Documentation: MkDocs</li> </ul>"},{"location":"#documentation-overview","title":"Documentation Overview","text":"<ul> <li>Setup and Installation</li> <li>Architecture</li> <li>API Reference</li> <li>Deployment</li> <li>FAQ</li> </ul> <p>Ready to get started? Head over to the Setup and Installation section.</p>"},{"location":"api/","title":"API Documentation","text":""},{"location":"architecture/","title":"Architecture Overview","text":"<p>This document provides a high-level look at how the Task Management System is organized. It covers the frontend (React + Vite), backend (Django REST Framework), the database (PostgreSQL), and any external services (like Cloudinary for media storage and hosting platforms like Render or Netlify).</p>"},{"location":"architecture/#1-high-level-diagram","title":"1. High-Level Diagram","text":"<p>Below is a simplified diagram of the system\u2019s architecture:</p> <pre><code>flowchart LR\n    A((\"Browser\")) --&gt;|HTTP Requests| B[\"React + Vite (Netlify)\"]\n    B --&gt;|API Calls| C[\"Django REST API (Render)\"]\n    C --&gt;|DB Queries| D[\"PostgreSQL\"]\n    C --&gt;|Media| E[\"Cloudinary\"]\n\n    style A fill:#f9f,stroke:#333,stroke-width:1px\n    style B fill:#9f9,stroke:#333,stroke-width:1px\n    style C fill:#99f,stroke:#333,stroke-width:1px\n    style D fill:#ff9,stroke:#333,stroke-width:1px\n    style E fill:#ccc,stroke:#333,stroke-width:1px\n</code></pre> <ul> <li>Frontend (Netlify): The React application is bundled with Vite and served via static hosting (e.g., Netlify).  </li> <li>Backend (Render): The Django REST API is hosted on a platform like Render, communicating with the database and external services.  </li> <li>PostgreSQL: The primary data store for tasks, users, and other relational data.  </li> <li>Cloudinary: Stores user-uploaded media (images, etc.).  </li> <li>User\u2019s Browser: Makes requests to the frontend (served on Netlify) which then calls the backend API routes.</li> </ul>"},{"location":"architecture/#2-frontend-react-vite","title":"2. Frontend (React + Vite)","text":"<ul> <li>React: Renders the UI and handles client-side routing (React Router).  </li> <li>Vite: Builds and bundles the application for development and production.  </li> <li>Data Fetching: Uses libraries like <code>axios</code> or <code>fetch</code> to call the Django REST API at URLs defined by environment variables (e.g., <code>VITE_REACT_APP_API_BASE_URL</code>).  </li> <li>Hosting: Deployed as static files on Netlify (or another service), which simply serves the compiled <code>dist/</code> folder.</li> </ul>"},{"location":"architecture/#3-backend-django-rest-framework","title":"3. Backend (Django REST Framework)","text":"<ul> <li>Django: The main Python web framework.  </li> <li>Django REST Framework (DRF): Exposes RESTful endpoints for tasks, users, comments, etc.  </li> <li>Database Interaction: Relies on PostgreSQL via <code>dj_database_url</code> or standard Django DB settings.  </li> <li>Authentication: Uses <code>rest_framework_simplejwt</code> for JWT-based token authentication.  </li> <li>Static/Media Files:  <ul> <li>WhiteNoise: Used for static files in production.  </li> <li>Cloudinary: Used for media file storage (images, attachments).  </li> </ul> </li> <li>Hosting: Render (or any other provider) runs the Django server process.  </li> </ul>"},{"location":"architecture/#4-database-postgresql","title":"4. Database (PostgreSQL)","text":"<ul> <li>Primary Data Store: Stores all persistent data: user info, tasks, comments, team data, etc.  </li> <li>Migrations: Handled via Django (<code>manage.py migrate</code>), ensuring schema consistency.  </li> <li>Configuration: <code>DATABASE_URL</code> environment variable sets the connection details (local or managed cloud DB).</li> </ul>"},{"location":"architecture/#5-external-services","title":"5. External Services","text":""},{"location":"architecture/#51-cloudinary","title":"5.1 Cloudinary","text":"<ul> <li>Used for media storage (e.g., user profile images, attachments).  </li> <li>Configured in <code>settings.py</code> with <code>CLOUDINARY_*</code> environment variables (and <code>django-cloudinary-storage</code>).  </li> <li>Provides URLs for accessing stored images/files.</li> </ul>"},{"location":"architecture/#52-mailgun-optional","title":"5.2 Mailgun (Optional)","text":"<ul> <li>If email notifications or password resets are configured, Mailgun handles sending transactional emails.  </li> <li><code>ANYMAIL</code> config in <code>settings.py</code> references <code>MAILGUN_API_KEY</code> and domain.</li> </ul>"},{"location":"architecture/#53-deployment-platforms","title":"5.3 Deployment Platforms","text":"<ul> <li>Render: Hosts the Django backend.  </li> <li>Typically you set up a Build Command (<code>pip install -r requirements.txt; python manage.py collectstatic</code>) and a Start Command (<code>gunicorn backend.wsgi</code>).  </li> <li>Netlify: Hosts the React frontend.  </li> <li>Build Command: <code>yarn build</code> (or <code>npm run build</code>)  </li> <li>Publish Directory: <code>dist</code></li> </ul>"},{"location":"architecture/#6-communication-flow","title":"6. Communication Flow","text":"<ol> <li>User Visits Frontend:  </li> <li> <p>The browser requests static files (HTML/CSS/JS) from Netlify\u2019s servers.  </p> </li> <li> <p>Frontend \u2192 Backend:  </p> </li> <li>The React app uses <code>axios</code> or <code>fetch</code> to send requests to the Django REST endpoints (e.g., <code>/api/v1/tasks/</code>).  </li> <li> <p>Sends JWT tokens in request headers (if authentication is required).  </p> </li> <li> <p>Backend \u2192 Database:  </p> </li> <li>Django queries the PostgreSQL DB to fetch or store task/user data.  </li> <li> <p>If there are media uploads, the files go to Cloudinary, and the DB stores a reference to the Cloudinary file URL.  </p> </li> <li> <p>Response:  </p> </li> <li>The Django REST API sends back JSON data, which React renders into the UI (e.g., list of tasks).  </li> </ol>"},{"location":"architecture/#7-security-authentication","title":"7. Security &amp; Authentication","text":"<ul> <li>JWT Auth:  </li> <li>Uses <code>SIMPLE_JWT</code> config in <code>settings.py</code> for token issuance (access + refresh tokens).  </li> <li>Frontend stores tokens (e.g., in localStorage or cookies) and includes them in request headers (<code>Authorization: Bearer &lt;token&gt;</code>).</li> <li>CORS Headers:  </li> <li>Django uses <code>django-cors-headers</code> to allow requests from the Netlify domain (<code>CORS_ALLOW_ALL_ORIGINS = True</code> in development or a restricted list in production).</li> </ul>"},{"location":"architecture/#8-key-points-best-practices","title":"8. Key Points &amp; Best Practices","text":"<ol> <li>Environment Variables </li> <li>Keep secrets (DB credentials, API keys) out of code; use <code>.env</code> files or platform-specific environment variable settings.  </li> <li>Version Control </li> <li>Store all code in a single repo (monorepo) or separate repos for frontend/backend, but keep them in sync.  </li> <li>Scalability </li> <li>For heavier loads, you can scale horizontally on Render (multiple instances of Django) and keep your PostgreSQL instance properly sized.  </li> <li>Netlify handles scaling for the static frontend automatically.  </li> <li>CD/CI </li> <li>Automate builds and tests so that each push to <code>main</code> triggers deployment or at least a test build.  </li> </ol>"},{"location":"architecture/#conclusion","title":"Conclusion","text":"<p>This architecture ensures clear separation of concerns:</p> <ul> <li>The React + Vite frontend handles all user-facing interfaces and renders dynamic content fetched from the Django REST API.  </li> <li>The Django REST backend serves as the centralized data and logic layer, interfacing with a PostgreSQL database and media storage in Cloudinary.  </li> <li>Hosting platforms (Render, Netlify) provide scalable environments to deploy your code with minimal DevOps overhead.</li> </ul> <p>Use this overview as a reference for how different parts of the system communicate, and refer to the Setup guides for detailed installation and configuration steps.</p>"},{"location":"backend_setup/","title":"Django Backend Setup","text":"<p>This guide will help you quickly set up and run the Django REST Framework backend for the Task Management System. By the end of these steps, you\u2019ll have a working local environment configured for PostgreSQL (or any database supported by <code>dj_database_url</code>).</p>"},{"location":"backend_setup/#1-prerequisites","title":"1. Prerequisites","text":"<ol> <li>Python 3.9+</li> <li>PostgreSQL (or an alternative database if you have a remote/PostgreSQL server)</li> <li>Git (to clone the repository)</li> <li>An .env file or environment variables configured for secrets and DB credentials (using <code>python-decouple</code>)</li> </ol>"},{"location":"backend_setup/#2-clone-the-repository","title":"2. Clone the Repository","text":"<p>If you haven\u2019t already, clone the main repository (which contains both backend and frontend):</p> <pre><code>git clone https://github.com/PacifistaPx0/task_manager.git\ncd backend\n</code></pre>"},{"location":"backend_setup/#3-create-and-activate-a-virtual-environment","title":"3. Create and Activate a Virtual Environment","text":"<p>It's recommended to create a Python virtual environment so dependencies don\u2019t conflict with other projects:</p> <pre><code># On macOS/Linux\npython -m venv venv\nsource venv/bin/activate\n\n# On Windows\npython -m venv venv\nvenv\\Scripts\\activate\n</code></pre>"},{"location":"backend_setup/#4-install-dependencies","title":"4. Install Dependencies","text":"<p>Navigate to the <code>backend/</code> folder and install the required packages from <code>requirements.txt</code>:</p> <pre><code>cd backend\npip install -r requirements.txt\n</code></pre> <p>This will install packages like Django, Django REST Framework, dj_database_url, python-decouple, and others:</p> <pre><code>asgiref==3.8.1\nDjango==5.0.7\ndjangorestframework==3.15.2\n...\nwhitenoise==6.8.2\n</code></pre>"},{"location":"backend_setup/#5-configure-environment-variables","title":"5. Configure Environment Variables","text":"<p>The project uses python-decouple to load environment variables from a file named <code>.env</code>. You\u2019ll need to create a <code>.env</code> file in the backend directory (the same folder as <code>settings.py</code>). Below is an example of what it might include (adjust values for your local environment):</p> <pre><code># .env file (do NOT commit real secrets to version control)\nSECRET_KEY=\"django-insecure-replace-with-a-real-key\"\nDEBUG=True\nALLOWED_HOSTS=127.0.0.1,localhost\n\n# PostgreSQL example (local)\nDATABASE_URL=\"postgres://db_user:db_password@127.0.0.1:5432/task_management_db\"\n\n# Cloudinary (for media storage)\nCLOUDINARY_CLOUD_NAME=\"your-cloud-name\"\nCLOUDINARY_API_KEY=\"your-cloudinary-key\"\nCLOUDINARY_API_SECRET=\"your-cloudinary-secret\"\n\n# Mailgun (for sending emails)\nMAILGUN_API_KEY=\"your-mailgun-key\"\nMAILGUN_SENDER_DOMAIN=\"your-mailgun-domain\"\nFROM_EMAIL=\"no-reply@yourdomain.com\"\n</code></pre> <p>Note: - <code>SECRET_KEY</code>: Replace with a secure, randomly generated key. - <code>DEBUG</code>: Should be <code>False</code> in production. - <code>ALLOWED_HOSTS</code>: Comma-separated list of hosts or domains that can serve the project. - <code>DATABASE_URL</code>: Points to your local or remote PostgreSQL instance. - Never commit this <code>.env</code> file to public version control.</p>"},{"location":"backend_setup/#6-database-setup","title":"6. Database Setup","text":""},{"location":"backend_setup/#option-a-using-dj_database_urlconfig","title":"Option A: Using <code>dj_database_url.config</code>","text":"<p>By default, <code>dj_database_url.config</code> in <code>settings.py</code> will read from your <code>DATABASE_URL</code> environment variable:</p> <pre><code>DATABASES = {\n    'default': dj_database_url.config(\n        default=config(\"DATABASE_URL\"), \n        conn_max_age=600\n    )\n}\n</code></pre> <p>Ensure that <code>DATABASE_URL</code> in your <code>.env</code> points to a valid PostgreSQL instance. For example:</p> <pre><code>DATABASE_URL=\"postgres://db_user:db_password@localhost:5432/task_management_db\"\n</code></pre> <p>Confirm that PostgreSQL is running locally or that you have network access to the remote DB.</p>"},{"location":"backend_setup/#option-b-local-db-settings-commented-out-in-settingspy","title":"Option B: Local DB Settings (Commented Out in <code>settings.py</code>)","text":"<p>If you prefer not to use <code>dj_database_url</code>, you can uncomment and use the following block in <code>settings.py</code>:</p> <pre><code>DATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.postgresql',\n        'NAME': config('DB_NAME'),\n        'USER': config('DB_USER'),\n        'PASSWORD': config('DB_PASSWORD'),\n        'HOST': config('DB_HOST'),\n        'PORT': config('DB_PORT', default='5432'),\n    }\n}\n</code></pre> <p>And in your <code>.env</code>:</p> <pre><code>DB_NAME=\"task_management_db\"\nDB_USER=\"postgres\"\nDB_PASSWORD=\"...\"\nDB_HOST=\"localhost\"\nDB_PORT=\"5432\"\n</code></pre>"},{"location":"backend_setup/#7-migrate-the-database","title":"7. Migrate the Database","text":"<p>After configuring your <code>.env</code> and database settings, run migrations:</p> <pre><code>python manage.py migrate\n</code></pre> <p>This will create all the necessary tables for Django\u2019s built-in apps as well as your custom apps (<code>api</code>, <code>task</code>, <code>userauths</code>).</p> <p>Creating a superuser (for Django admin access), run:</p> <pre><code>python manage.py createsuperuser\n</code></pre>"},{"location":"backend_setup/#8-run-the-development-server","title":"8. Run the Development Server","text":"<p>Launch the local dev server:</p> <pre><code>python manage.py runserver\n</code></pre> <p>By default, Django will listen on <code>http://127.0.0.1:8000</code>. You can visit that URL in your browser to confirm everything is working. If you have Django REST Framework browsable API views configured, you\u2019ll see them.</p>"},{"location":"backend_setup/#9-static-files-and-media","title":"9. Static Files and Media","text":"<p>Static Files: - The project uses WhiteNoise (<code>whitenoise.middleware.WhiteNoiseMiddleware</code>) for static file handling in production. - Locally, Django\u2019s dev server serves static files automatically.</p> <p>Media Files: - For media uploads, the project uses Cloudinary (<code>cloudinary_storage.storage.MediaCloudinaryStorage</code>) if <code>CLOUDINARY_*</code> env variables are set. - Check <code>settings.py</code> for the <code>DEFAULT_FILE_STORAGE</code> configuration.</p>"},{"location":"backend_setup/#10-useful-commands","title":"10. Useful Commands","text":"<ul> <li> <p>Install a New Package: <code>bash   pip install &lt;package_name&gt;   pip freeze &gt; requirements.txt  # update the requirements file</code></p> </li> <li> <p>Run Tests: <code>bash   python manage.py test   # or to check coverage if you use the coverage library   coverage run manage.py test   coverage report -m</code></p> </li> <li> <p>Compile Messages/Translations (if using i18n features): <code>bash   django-admin makemessages   django-admin compilemessages</code></p> </li> </ul>"},{"location":"backend_setup/#11-troubleshooting","title":"11. Troubleshooting","text":"<ul> <li>Cannot connect to database:</li> <li>Check if PostgreSQL is running.</li> <li> <p>Verify your <code>DATABASE_URL</code> or local DB settings.</p> </li> <li> <p>Missing .env variables:</p> </li> <li> <p>Make sure <code>.env</code> is in the correct directory (same as <code>settings.py</code>) and that you have <code>python-decouple</code> installed.</p> </li> <li> <p>Static files not loading:</p> </li> <li>Ensure <code>whitenoise.middleware.WhiteNoiseMiddleware</code> is in <code>MIDDLEWARE</code>.</li> <li> <p>Run <code>collectstatic</code> if you\u2019re simulating a production environment.</p> </li> <li> <p>Email sending issues:</p> </li> <li>Double-check your Mailgun or other email provider credentials in <code>.env</code>.</li> </ul>"},{"location":"backend_setup/#conclusion","title":"Conclusion","text":"<p>By following the steps above, you will have a fully functional Django REST backend for the Task Management System. Here\u2019s a quick recap:</p> <ol> <li>Install Dependencies</li> <li> <p>Use a dedicated Python virtual environment and run <code>pip install -r requirements.txt</code> in the <code>backend/</code> folder.</p> </li> <li> <p>Configure Environment Variables</p> </li> <li> <p>Create a <code>.env</code> file (using <code>python-decouple</code>) to store sensitive information like <code>SECRET_KEY</code>, <code>DATABASE_URL</code>, and any third-party credentials.</p> </li> <li> <p>Migrate the Database</p> </li> <li> <p>Run <code>python manage.py migrate</code> to set up your tables and <code>python manage.py createsuperuser</code> if you need admin access.</p> </li> <li> <p>Run the Server</p> </li> <li> <p>Launch with <code>python manage.py runserver</code> to start the dev server on <code>http://127.0.0.1:8000</code>.</p> </li> <li> <p>Additional Services</p> </li> <li>WhiteNoise for static files and Cloudinary for media uploads (if configured).</li> <li>CORS headers enabled for cross-origin requests from your React frontend.</li> </ol> <p>At this point, your Django REST Framework API should be ready to handle requests from the frontend or any HTTP client. Refer back to this guide whenever you need to reinstall, reconfigure, or troubleshoot your backend environment. If you encounter any issues, be sure to consult the Troubleshooting section, the Django and Django Rest Framework documentation, or your version control history for further clues.</p>"},{"location":"deployment/","title":"Deployment","text":"<p>This guide explains how to deploy the Task Manager Application\u2014consisting of a Django REST backend and a React + Vite frontend\u2014to Render (for the backend) and Netlify (for the frontend).</p>"},{"location":"deployment/#1-overview","title":"1. Overview","text":"<ul> <li>Frontend: Deployed as a static site on Netlify, pointing to your compiled React + Vite <code>dist/</code> folder.</li> <li>Backend: Deployed on Render as a Web Service. It runs Django, handles API requests, and interacts with the PostgreSQL database and external services like Cloudinary.</li> </ul>"},{"location":"deployment/#2-prerequisites","title":"2. Prerequisites","text":"<ol> <li>Render Account: Render Sign-up</li> <li>Netlify Account: Netlify Sign-up</li> <li>Repository on GitHub containing both frontend and backend folders.</li> </ol>"},{"location":"deployment/#3-backend-deployment-render","title":"3. Backend Deployment (Render)","text":""},{"location":"deployment/#31-prepare-your-django-backend","title":"3.1. Prepare Your Django Backend","text":"<ol> <li>Requirements: Make sure <code>requirements.txt</code> is up to date.<ul> <li>Include <code>gunicorn</code>, <code>whitenoise</code>, and any other production dependencies.</li> </ul> </li> <li>Procfile (Optional): If needed, specify how to run your app.     <code>bash     web: gunicorn backend.wsgi:application --log-file -</code>     This is often optional if Render can infer the command from your settings.</li> </ol>"},{"location":"deployment/#32-render-project-setup","title":"3.2. Render Project Setup","text":"<ol> <li>Create a New Web Service<ul> <li>Log in to Render and choose \u201cNew\u201d \u2192 \u201cWeb Service\u201d.</li> <li>Connect it to your Git repo.</li> <li>Select the <code>backend/</code> folder if Render asks for a root directory (or specify in the build command).</li> </ul> </li> <li> <p>Build &amp; Start Commands</p> <ul> <li>Build Command:  <code>bash  pip install -r requirements.txt  python manage.py collectstatic --noinput  python manage.py migrate</code></li> <li>Start Command:  <code>bash  gunicorn backend.wsgi:application</code></li> <li>Adjust the path to <code>manage.py</code> if your Django files aren\u2019t in the root.</li> </ul> </li> <li> <p>Environment Variables</p> <ul> <li>In Render\u2019s \u201cEnvironment\u201d tab, add variables like:<ul> <li><code>SECRET_KEY</code></li> <li><code>DATABASE_URL</code></li> <li><code>DEBUG=False</code></li> <li><code>CLOUDINARY_*</code> keys (if you store media on Cloudinary)</li> <li><code>MAILGUN_*</code> (if you send emails)</li> </ul> </li> <li>Important: Mark them as \u201cSecret Files\u201d if needed and never commit real secrets to Git.</li> </ul> </li> </ol>"},{"location":"deployment/#33-database-postgresql","title":"3.3. Database (PostgreSQL)","text":"<ul> <li>Either:<ul> <li>Use Render\u2019s managed PostgreSQL (create a new DB in Render).</li> <li>Or link to an external DB service.</li> </ul> </li> <li>Ensure <code>DATABASE_URL</code> is set accordingly in your Render environment variables.</li> </ul>"},{"location":"deployment/#34-verify-deploy","title":"3.4. Verify &amp; Deploy","text":"<ol> <li>Deploy the service (Render will run the build command, then the start command).</li> <li>Check Logs to confirm:<ul> <li>Pip installed dependencies</li> <li>Migrations ran successfully</li> <li><code>gunicorn</code> started without error</li> </ul> </li> </ol> <p>Once it\u2019s live, Render provides a unique subdomain (e.g., <code>your-app.onrender.com</code>). That URL will serve the Django API endpoints.</p>"},{"location":"deployment/#4-frontend-deployment-netlify","title":"4. Frontend Deployment (Netlify)","text":""},{"location":"deployment/#41-prepare-your-react-vite-app","title":"4.1. Prepare Your React + Vite App","text":"<ol> <li>Build Script: Ensure <code>package.json</code> has:      <code>json      {         \"scripts\": {           \"build\": \"vite build\",           \"dev\": \"vite\"         }      }</code></li> <li>Environment Variables:<ul> <li>If you need a different API base URL in production, you can set a Netlify environment variable <code>VITE_REACT_APP_API_BASE_URL</code> to point to the Render domain (e.g., <code>https://your-backend.onrender.com/api/v1/</code>).</li> </ul> </li> </ol>"},{"location":"deployment/#42-create-a-new-netlify-site","title":"4.2. Create a New Netlify Site","text":"<ol> <li>Netlify Dashboard \u2192 \u201cNew site from Git\u201d.</li> <li>Connect Repo: Authorize GitHub/GitLab and pick your repo.</li> <li>Build Command: <code>yarn build</code> or <code>npm run build</code> (depending on your package manager).</li> <li>Publish Directory: <code>dist</code> (Vite\u2019s default build output).</li> <li>Environment Variables (Optional):<ul> <li>If you want the frontend to call your Render domain, add:  <code>bash  VITE_REACT_APP_API_BASE_URL=\"https://your-backend.onrender.com/api/v1/\"</code></li> </ul> </li> <li>Deploy: Netlify will automatically install dependencies, run build, and serve the <code>dist/</code> folder at a generated subdomain (e.g., <code>https://my-app.netlify.app</code>).</li> </ol>"},{"location":"deployment/#5-connecting-frontend-backend","title":"5. Connecting Frontend &amp; Backend","text":"<p>Once both services are live:</p> <ol> <li>Set the API Base URL in the frontend environment variable:<ul> <li><code>VITE_REACT_APP_API_BASE_URL = https://your-backend.onrender.com/api/v1/</code></li> </ul> </li> <li>Redeploy the frontend so that it uses the correct base URL for API calls.</li> </ol>"},{"location":"deployment/#6-testing-the-production-setup","title":"6. Testing the Production Setup","text":"<ol> <li>Open Your Netlify URL: <code>https://my-app.netlify.app</code></li> <li>Attempt to Log In / Fetch Data: The React app should successfully call the Render API.</li> <li>Check Browser DevTools if there are CORS or network errors. If so:<ul> <li>Ensure you have <code>django-cors-headers</code> configured and <code>CORS_ALLOW_ALL_ORIGINS</code> or the appropriate domain whitelisting in <code>settings.py</code>.</li> </ul> </li> </ol>"},{"location":"deployment/#7-common-issues","title":"7. Common Issues","text":"<ol> <li>Free Tier Cold Start (Render)<ul> <li>If you\u2019re on Render\u2019s free tier, your backend may go to sleep if inactive. This can cause a brief startup delay (30-50 seconds).</li> <li>You might display a small loading message in the frontend or note this in your docs.</li> </ul> </li> <li>Incorrect Build Commands<ul> <li>Double-check that your Netlify build command matches your <code>package.json</code> script name.</li> <li>Confirm that Render\u2019s build command is installing Python dependencies, migrating, and collecting static files.</li> </ul> </li> <li>Missing Environment Variables<ul> <li>If your app fails to connect to the database or use third-party services, confirm env vars are set on the correct platform (Render for backend, Netlify for frontend).</li> </ul> </li> <li>CORS Errors<ul> <li>Make sure your Django settings include:  <code>python  INSTALLED_APPS = [       ...       'corsheaders',  ]  MIDDLEWARE = [       'corsheaders.middleware.CorsMiddleware',       ...  ]  CORS_ALLOW_ALL_ORIGINS = True  # or restrict to your Netlify domain</code>  Redeploy if you make changes to these settings.</li> </ul> </li> </ol>"},{"location":"deployment/#8-wrapping-up","title":"8. Wrapping Up","text":"<p>By following these steps:</p> <ol> <li>Backend on Render: You have a live Django REST API with a PostgreSQL database, environment variables, static files managed by WhiteNoise, and optional Cloudinary for media.</li> <li>Frontend on Netlify: You have a React + Vite project that\u2019s compiled and served as static files with environment variables pointing to the Render backend.</li> </ol> <p>Users access the Netlify URL, which loads the React app, then communicates with the Render-based Django API. For further automation, you can enable continuous deployment on both Netlify and Render so that every push to main triggers a new build and deploy.</p>"},{"location":"frontend_setup/","title":"Frontend Setup (React + Vite)","text":"<p>This document explains how to install and run the React + Vite frontend of the Task Management System. By the end, you\u2019ll have a local development environment running at <code>http://127.0.0.1:5173</code> (or a different port if Vite chooses one dynamically).</p>"},{"location":"frontend_setup/#prerequisites","title":"Prerequisites","text":"<ul> <li>Node.js 14+ (recommended: Node 16+)</li> <li>Yarn (instead of npm)</li> <li>Git (to clone the repository)</li> </ul>"},{"location":"frontend_setup/#cloning-the-repository","title":"Cloning the Repository","text":"<p>If you haven\u2019t already, clone the main repository (which contains both frontend and backend). The frontend code is in the <code>frontend/</code> directory:</p> <pre><code>git clone https://github.com/PacifistaPx0/task_manager.git\ncd frontend\n</code></pre>"},{"location":"frontend_setup/#install-dependencies-with-yarn","title":"Install Dependencies with Yarn","text":"<p>Inside the <code>frontend/</code> folder, install dependencies via Yarn:</p> <pre><code>yarn\n</code></pre> <p>This command reads <code>package.json</code> and fetches all necessary libraries like React, Vite, Tailwind, and so on:</p> <pre><code>{\n    \"dependencies\": {\n        \"react\": \"^18.2.0\",\n        \"axios\": \"^1.6.5\",\n        \"react-router-dom\": \"6.10.0\"\n    },\n    \"devDependencies\": {\n        \"@vitejs/plugin-react\": \"^4.0.3\",\n        \"tailwindcss\": \"^3.4.10\",\n        \"vite\": \"^4.4.5\"\n    }\n}\n</code></pre>"},{"location":"frontend_setup/#configure-environment-variables","title":"Configure Environment Variables","text":"<p>Create or modify your <code>.env</code> file in the <code>frontend/</code> folder to set the API base URL. For example:</p> <pre><code>VITE_REACT_APP_API_BASE_URL=https://your-api-end-point/\n# or for local dev:\n# VITE_REACT_APP_API_BASE_URL=http://127.0.0.1:8000/api/v1/\n</code></pre> <p>Notes on Vite Environment Variables:</p> <ul> <li>All variables must start with <code>VITE_</code> to be exposed in the client bundle.</li> <li>Access them in your React code via <code>import.meta.env.VITE_REACT_APP_API_BASE_URL</code>.</li> </ul>"},{"location":"frontend_setup/#tailwind-css-configuration","title":"Tailwind CSS Configuration","text":"<p>Your <code>tailwind.config.js</code> might look like this:</p> <pre><code>/** @type {import('tailwindcss').Config} */\nexport default {\n    content: [\n        \"./index.html\",\n        \"./src/**/*.{js,ts,jsx,tsx}\"\n    ],\n    theme: {\n        extend: {}\n    },\n    plugins: []\n}\n</code></pre> <p>And <code>postcss.config.js</code> might look like:</p> <pre><code>export default {\n    plugins: {\n        tailwindcss: {},\n        autoprefixer: {}\n    }\n};\n</code></pre> <p>Ensure you\u2019ve imported your main CSS (e.g., <code>index.css</code>) in your React entry file (often <code>main.jsx</code> or <code>App.jsx</code>) and that it includes the Tailwind directives:</p> <pre><code>/* index.css */\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n</code></pre>"},{"location":"frontend_setup/#development-server","title":"Development Server","text":"<p>To start the local development server, run:</p> <pre><code>yarn dev\n</code></pre> <p>Vite defaults to <code>http://127.0.0.1:5173</code> (or another port if 5173 is busy). Make sure your backend is running (if you need live API calls).</p>"},{"location":"frontend_setup/#building-for-production","title":"Building for Production","text":"<p>When you\u2019re ready to create a production build:</p> <pre><code>yarn build\n</code></pre> <p>This will generate a <code>dist/</code> folder containing optimized, minified static files. You can deploy <code>dist/</code> to any static hosting service (e.g., Netlify, GitHub Pages, or a custom server).</p>"},{"location":"frontend_setup/#common-troubleshooting","title":"Common Troubleshooting","text":"<ul> <li>API Calls Fail<ul> <li>Check <code>VITE_REACT_APP_API_BASE_URL</code> in <code>.env</code>.</li> <li>Ensure your backend is live and your CORS settings allow requests from <code>127.0.0.1:5173</code>.</li> </ul> </li> <li>Tailwind Styles Not Applying<ul> <li>Verify <code>@tailwind base; @tailwind components; @tailwind utilities;</code> in your main CSS file.</li> <li>Check content paths in <code>tailwind.config.js</code> so Tailwind can parse your JSX files.</li> </ul> </li> <li>Environment Variables Not Detected<ul> <li>Make sure your variable names begin with <code>VITE_</code>.</li> <li>Confirm you\u2019re referencing them correctly in React code: <code>import.meta.env.VITE_REACT_APP_API_BASE_URL</code>.</li> </ul> </li> <li>Port Conflicts<ul> <li>If 5173 is taken, Vite will pick another. Watch the console output for the actual dev server URL.</li> </ul> </li> </ul>"},{"location":"frontend_setup/#conclusion","title":"Conclusion","text":"<p>With these steps, you should be able to:</p> <ol> <li>Install dependencies via Yarn.</li> <li>Configure <code>.env</code> for your API base URL and any other environment vars.</li> <li>Use Tailwind CSS by importing it in your <code>index.css</code> or <code>App.css</code>.</li> <li>Run the app locally with <code>yarn dev</code>.</li> <li>Build for production with <code>yarn build</code>, and optionally deploy to Netlify or another static hosting provider.</li> </ol> <p>If you need more details on Vite or Yarn, refer to the official Vite and Yarn documentation. For styling references, consult the Tailwind CSS docs.</p>"}]}